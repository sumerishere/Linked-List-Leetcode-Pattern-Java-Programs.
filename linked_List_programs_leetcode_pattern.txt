  // ---------------------Linked List common Pattern Questions -------------------//

               ----- Easy level questions of leetcode with solutions -----



1. Merge Two Sorted Lists : (que link: https://leetcode.com/problems/merge-two-sorted-lists )

    Sample Test case : 
           Input: list1 = [1,2,4], list2 = [1,3,4]
           Output: [1,1,2,3,4,4].

   Solution :
      
       class Solution {
          public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        
             ListNode tmp = new ListNode(0);   //sentinel / dummy node for list operation.
             ListNode res = tmp;             //created final return node to return from starting of sorted list.
         
             while( l1!=null && l2!=null){    //ensuring l1 and l2 both should not be null. 
            
                if(l2.val > l1.val){    // comparing l1 and l2 values for sorting in ascending order.
                   tmp.next = l1;        //adding val in tmp created node or in sentinel node.
                   l1 = l1.next;       
                }
                else{
                   tmp.next = l2;     //same for l2 or vice-verssa of l1.
                   l2 = l2.next;
                }
                tmp = tmp.next;  //and one more thing tmp should also increament after checking for both list.
             }
        
            if(l1 != null) tmp.next = l1;   // handling edge case for remaining node of l1.
            if(l2 != null) tmp.next = l2;     // handling edge case for remaining node of l2.
        
            return res.next;    //skipping inicialized val of sentinel or tmprary node.
        }
     }

 
2. Remove Duplicates from Sorted List. (que link : https://leetcode.com/problems/remove-duplicates-from-sorted-list ).

    Sample Test case : 
             Input: head = [1,1,2]
             Output: [1,2].
  
    Solution : 

           class Solution {
               public ListNode deleteDuplicates(ListNode head) {
        
         
                   if(head == null || head.next == null){   //handling empty or single node case.
                       return head ;
                   }

                   ListNode res = head;     //result node
     
                   while( res!= null && res.next != null){
                       if(res.val == res.next.val){         //if value got same betwn two nodes simply skip that one node.
                          res.next = res.next.next;
                      }
                      else{
                          res = res.next;      //iterate
                      }
                   }
                   return head;    //final sorted unique list.
               }
            } 

3. Linked List Cycle (floyd's cycle). (que link : https://leetcode.com/problems/linked-list-cycle ).

      Sample Test case : 

          Input: head = [3,2,0,-4], pos = 1
          Output: true
          Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
   
     Solution :
              public class Solution {
                 public boolean hasCycle(ListNode head) {

               // 1. Slow-Fast Pointer approach or floyd's appraoch.
        
    
                    ListNode slow_pnt = head;   
                    ListNode fast_pnt = head;
        
                    while(fast_pnt!= null && fast_pnt.next != null){

                         if(slow_pnt == fast_pnt.next) return true;
            
                         slow_pnt = slow_pnt.next;
                         fast_pnt = fast_pnt.next.next;
                    }
                    return false;
        

                 // 1. HashSet--> using hashset approach checking the repeation of pointer to find the LL cycle.
        
                     HashSet<ListNode> set =  new HashSet<>();
        
                     ListNode pointer = head;
        
                     while(pointer != null){

                        if(set.contains(pointer)) return true;
                        set.add(pointer);
                        pointer = pointer.next;
                     }
                     return false;
                 }
               }








